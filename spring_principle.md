객체 지향 설계의 5가지 원칙 SOLID
---
* SRP 단일 책임 원칙 : 하나의 클래스는 하나의 책임만 가져야함
* OCP 개방 폐쇄 원칙 : 확장에는 열려있고 변경에는 닫혀 있어야함
* LSP 리스코프 치환 원칙 : 객체는 정확성을 깨뜨리지 않으면서 하위 타입 인스턴스를 바꿀 수 있어야함
* ISP 인터페이스 분리 원칙 : 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
* DIP 의존 관계 역전 원칙 : 추상화에 의존해야하고 구체화에 의존하지 말아야 한다.


스프링의 기초
---
* 프레임워크 vs 라이브러리
  
  작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크
  
  작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리
* IoC 제어의 역전 : 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
* 객체를 생성, 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 한다.


스프링 컨테이너
---
* ApplicationContext는 스프링 컨테이너 및 인터페이스이다.

  new AnnotationConfigApplicationContext(클래스명.class)는 ApplicationContext 인터페이스의 구현체이다.
* 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
* 빈이름은 기본적으로 메서드 이름을 사용하고 직접 부여할 수 있다.

  하지만 같은 이름을 부여하면 다른 빈이 무시되거나, 기존 빈을 덮어버리는 오류가 발생할 수 있다.

싱글톤 컨테이너
---
* 싱글톤 패턴 : 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다.
* 싱글톤 컨테이너 : 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리한다.
  스프링 빈이 싱글톤으로 관리되는 빈이다.
  
  - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
  - DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.
* 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(state)하게 설계하면 안된다.
* 무상태(stateless)로 설계해야한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야한다.
  - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.
* @Configuration과 바이트코드 조작
  스프링이 자바 코드까지 싱글톤 보장을 하는 것은 어렵다. 하지만 @Configuration 라이브러리를 적용하면 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 상속받아 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다.
* 클래스 앞에 @Configuration과 메소드 앞에 @Bean을 붙여야 싱글톤이 적용되어 스프링 컨테이너에 스프링 빈이 등록된다.

컴포넌트 스캔
---
* @ComponentScan은 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
* @ComponentScan을 사용할때 @Configuration이 붙은 설정 정보도 자동으로 등록되기 때문에 excludeFilters를 이용하여 설정 정보를 컴포넌트 스캔 대상에서 제외한다.
* basePackages : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함한 하위 패키지를 모두 탐색한다.

의존관계 자동 주입
---
* 생성자가 1개만 존재하면 @Autowired를 생략해도 자동 주입 된다. 스프링 빈에만 해당.
* lombok : 롬복 라이브러리를 적용하면 @RequiredArgsConstructor 기능을 사용하여 final이 붙은 모든 필드를 생성자로 만들어준다. 생성자를 1개만 두고 @Autowired를 생략하는 방법을 주로 사용한다.
* @Autowired는 타입 매칭을 시도하고, 이때 여러 빈이 존재하면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
* @Qualifier는 추가 구분자를 붙여준다. 추가적인 방법을 제공하는 것이고 빈 이름을 변경하는 것은 아니다.
  - @Qualifier끼리 매칭
  - 빈 이름 매칭
  - NoSuchBeanDefinitionException 예외 발생
* @Primary는 우선순위를 정하는 방법이다. @Autowired로 여러 빈이 매칭되면 @Primary가 우선권을 가진다.

빈 생명주기 콜백
---
* 스프링 빈의 이벤트 라이프사이클

  스프링 컨테이너 생성 => 스프링 빈 생성 => 의존관계 주입 => 초기화 콜백 => 사용 => 소멸전 콜백 => 스프링 종료
  
  초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료되고 호출
  소멸전 콜백 : 빈이 소멸되기 직전에 호출
* 빈 등록 초기화, 소멸 메서드 지정 @Bean(initMethod = "init", destroyMethod = "close")로 지정할 수 있다.

  @Bean의 destoryMethod는 기본값이 (inferred)(추론)으로 등록되어있다.
  
  이 추론 기능은 close나 shutdown라는 이름의 메소드를 자동으로 호출해준다.
  
  그래서 종료 메서드는 따로 적어주지 않아도 잘 동작한다. 추론 기능을 사용하지 않으려면 destroyMethod = ""으로 저장하면된다.
* @PostConstruct를 초기화 메소드 앞에, @PreDestory를 종료 메소드 앞에 붙여주면 실행된다.

빈 스코프
---
* 빈 스코프 : 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어서 종료될 때까지 유지하는데 스프링 빈이 싱글톤 스코프로 생성되기 때문이다. 스코프는 빈이 존재할 수 있는 범위를 뜻한다.
* 스코프의 종류
  
  - 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
  - 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 유지되는 매우 짧은 범위의 스코프이다.
  - 웹 관련 스코프 : 대표적으로 requset가 있고 웹 요청이 들어오고 나갈 때까지 유지되는 스코프이다.
* 프로토타입 스코프
  - 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다. 반면에 프로토타입 스코프를 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.
  - 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 빈을 관리하지 않는다. 그래서 @PreDestroy 같은 종료 메서드는 호출되지 않는다.

* 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 해결
  - 스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다. 하지만 싱글톤 빈과 함께 사용할 때는 의도한 대로 동작하지 않는다.
  - 의존관계를 외부에서 주입(DI)받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회라 한다.
  - DL 서비스는 Provider<클래스명>으로 생성하여 .get() 메서드를 호출해서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
  
* 웹 스코프
  - 웹 스코프는 웹 환경에서만 동작하고 스프링이 해당 스코프 종료시점까지 관리하기에 종료 메서드가 호출된다.
  - requset : 웹 스코프 종류의 하나로 HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 인스턴스가 생성, 관리된다.
  - 스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있다.
  - 해결 방안으로는 Provider를 사용하면 되지만, 프록시가 더 효율적이다.
  - 프록시
    + 클래스 상단에 @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)를 추가한다. 적용 대상이 인터페이스면 INTERFACES를 선택하면 된다.
    + 이렇게 하면 가짜 프록시 클래스를 만들어두고 HTTP request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입할 수 있다.
    + CGLIB라는 라이브러리로 내 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입한다. 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.
      싱글처럼 작동한다.
    + 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 필요한 시점까지 지연처리를 한다. 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
